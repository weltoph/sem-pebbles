\documentclass[draft,oneside]{scrartcl}

\usepackage[utf8]{inputenc}

\usepackage{epigraph}
\usepackage[autostyle,german=guillemets]{csquotes}
\usepackage[ngerman, english]{babel}
\usepackage[style=numeric,backend=biber]{biblatex}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{todonotes}
\usepackage{mdframed}
\usepackage{wrapfig}

\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{ex}{Exercise}

\addbibresource{bibliography.bib}

\DeclareMathOperator{\din}{\delta_{\mathit{in}}}
\DeclareMathOperator{\dout}{\delta_{\mathit{out}}}
\DeclareMathOperator{\Tid}{T_{\text{id}}}
\DeclareMathOperator{\Tsteps}{T_{\text{steps}}}
\DeclareMathOperator{\Twalk}{T_{\text{walk}}}
\DeclareMathOperator{\Thead}{T_{\text{head}}}

\begin{document}

\input{tikz/settings}

\setlength{\epigraphwidth}{0.7\textwidth}
\setquotestyle{german}

\title{A \emph{Grimm} idea}
\subtitle{Exploring graphs with pebbles}
\author{Christoph Welzel}
\maketitle

\begin{abstract}
  In this paper we re-present and explain an approach on exploring large
  undirected graphs with the help of markers, so called pebbles, for vertices.
  We focus on the central ideas of this approach and explain why it is possible
  to traverse any graph with $n$ vertices with $\Theta(\log \log n)$ pebbles
  and the same amount of memory.
\end{abstract}

\epigraph{Und als der volle Mond aufgestiegen war, so nahm Hänsel sein %
Schwesterchen an der Hand und ging den Kieselsteinen nach, die schimmerten %
wie neu geschlagene Batzen und zeigten ihnen den Weg.}%
{\emph{Hänsel und Gretel}\\Brüder Grimm}

\setquotestyle{english}
\section{Introduction}
Traversing large graphs is an interesting challenge. In times of the internet
web crawlers have to traverse immense graphs but also regarding complexity
theory this is an interesting problem. First we will informally introduce two
complexity classes to illustrate the importance of graph traversal from a
complexity point of view: $L$ as the class of problems that can be solved by
a deterministic Turing machine with additional memory of logarithmic amount
of the input. And $SL$ as the class of problems that can be solved with the
same space requirements but by a non-deterministic symmetrical Turing machine,
where symmetrical means that for every computation step of the Turing machine
there is a computation step to undo the previous one. As it turns out checking
if two vertices $s$ and $t$ are connected in an undirected graph is a problem
that is complete for $SL$. This problem is often refered to as
$\mathrm{USTCON}$ and \citeauthor{logspacealg} showed in \cite{logspacealg}
that $\mathrm{USTCON}\in L$ which collapsed $SL$ into $L$, hence $SL = L$.
In the following we will present the results from \cite{pebbles} where another
mechanism of graph exploration is used: with the use of pebbles which are small
pieces of memory that can be dropped on and collected from the vertex as an
agent traverses the graph. As we will show it is possible to traverse a graph
with $n$ vertices with $\mathcal{O}(\log\log n)$ memory and the same amount of
pebbles. Furthermore we will explain why there is no smaller amount of memory
or pebbles to generally obtain the same guarantee to traverse all $n$ vertices.

\section{Preliminaries}
For the course of this paper we assume the following: Firstly, the vertices can
not be distinguished by the traversing agent. But as the agent moves on a
vertex it can compute its degree. Secondly, the edges attached to the vertex
can be locally distinguished and are enumerated with the indices
$\left\{0,\dots,d_{v}-1\right\}$ where $d_{v}$ denotes the degree of the vertex
$v$. We refer to the \enquote{index} of the edge as its \emph{port}. Note that
every edge thus has two different ports and furthermore that there is no
relation between the ports is assumed. Additionally the degree of the
considered graphs are assumed to be limited by a constant $\Delta$ and that
there are only a finite amount of vertices.

\section{Pebble machines}
We are now ready to introduce the model of pebble machines formally. It closely
follows the notion of Turing machines but adds mechanisms to model the
movements of the agent. The presented model of pebble machines thus have
\begin{enumerate}
  \item a finite set of states $Q$
  \item a finite set of final states $F\subseteq Q$
  \item a finite set of distinguishable pebbles $P$
  \item a length of the used memory tape $m$
  \item a computation function $\delta$
  \item a function that describes the movement onto a vertex
    $\din$
  \item a function that describes the leaving of a vertex $\dout$
  \item an inital state $q_{0}$
\end{enumerate}
where formally the computation function models the behaviour of the pebble
machine as follows:
\begin{equation*}
  \delta\colon (Q\setminus F)\times\left\{0,1\right\}\rightarrow
  Q\times\left\{0,1\right\}\times\left\{L,R\right\}
\end{equation*}
with the typical understanding of the computation of a Turing machine.
As an agent traverses a vertex it is aware of the pebbles it carries
around, it observes the set of pebbles on the vertex and the degree of the
vertex and it furthermore aware of the port that it entered through.
Thus we use
\begin{equation*}
  \din\colon Q\times 2^{P}\times 2^{P}\times
  \left\{0,\dots,\Delta - 1\right\}\times\left\{0,\dots,\Delta - 1\right\}
  \rightarrow Q
\end{equation*}
to model this behaviour. And finally as the agent leaves a vertex it leaves
a set of pebbles behind, picks up another set and chooses the port it leaves
through. We choose to model this behaviour as
\begin{equation*}
  \dout\colon Q
  \rightarrow 2^{P}\times 2^{P}\times \left\{0,\dots,\Delta - 1\right\}
\end{equation*}
Of course we also demand consistency of the pebbles, i.e. that if the agent
carried $P_{1}\subseteq P$ and found $P_{2}\subseteq P$ it is necessary that
$P_{1}$ and $P_{2}$ are disjoint and furthermore that if the agent leaves
carrying $P'_{1}$ and leaving $P'_{2}$ behind those sets are disjoint and
$P_{1}\cup P_{2} = P'_{1}\cup P'_{2}$.

\section{Graph exploration}
In order to describe the movement of an agent we introduce the notion of an
exploration sequence as $e_{0}, e_{1},\dots$ which models relative movements
as follows. We use a sequence of variables $l_{0},l_{1},\dots$ which denotes
the port a vertex was entered through. And the next vertex is determined as the
one connected to the port $(l_{i} + e_{i}) \mod d_{v_{i}}$. We define
$l_{0} = 0$ and the notion $(e_{0},\dots,e_{k})^{\ast}$ for periodic sequences.
It can be shown that a periodic sequence produces a closed walk through a
graph.
\begin{proof}
  We argue that there is only a finite amount of triples of the
  form $(v,l,i)$ where currently the agent is on vertex $v$, entered
  this vertex through port $l$ and is currently at index $i$ of the exploration
  sequence. For two triples $(v',l',i')$ and $(v'',l'',i'')$ that both lead to
  $(v,l,i)$ it is easy to see, that $(v',l',i') = (v'',l'',i'')$. Thus, for
  every triple there is a unique predecessor and successor which implies due to
  the finiteness of the triples $(v,l,i)$ and because the agent moves
  infinitely that the first triple has to be valid infinitly often.
  This means a periodic exploration sequence yields a closed walk.
\end{proof}

From the following result of \cite{logspacealg} we present how we can obtain
an $(\mathcal{O}(1),0,\mathcal{O}(\log n))$ pebble machine that finds a closed
walk of at least $n$ distinct vertices in any graph with bounded degree.
\begin{thm}
  \label{thm:logalg}
There is an algorithm $M\in L$ which produces a universal exploration sequence
for every regular graph with $n$ vertices.
\end{thm}
First we argue that we can use this algorithm to find a universal exploration
sequence of the form $e=(e_{0},\dots,e_{k})^{\ast}$ that traverses $n$ distinct
vertices for any 3-regular graph and requires only $\mathcal{O}(\log n)$
memory. Therefore we rely on the traversal sequence of $M$ from Theorem
\ref{thm:logalg} and take from that the first $k:=3n\cdot c$ indices where
$c$ denotes the number of configurations of $M$. We can now be assured that
$e$ actually is a universal traversal sequence for any 3-regular graph because
otherwise $M$ would have already looped in a strict subset of vertices of some
3-regular graph. This contradicts that $M$ produces a universal exploration
sequence for any graph with $n$ vertices.

We can now find the $(\mathcal{O}(1),0,\mathcal{O}(\log n))$ pebble machine we
are looking for.
\begin{thm}
  \label{thm:pebblewalk}
  There is a $(\mathcal{O}(1),0,\mathcal{O}(\log n))$ pebble machine which
  explores every given graph $G$ with bounded degree $\Delta$ either completly
  or at least loops on $n$ distinct vertices.
\end{thm}
\begin{wrapfigure}{r}{0.6\textwidth}
  \caption{Illustration how to transform any graph to a 3-regular graph.}
  \label{fig:3reg}
  \resizebox{0.6\textwidth}{!}{\input{tikz/regsim}}
\end{wrapfigure}
\begin{proof}
  The main idea is to use the adapted algorithm $A$ to find for an
  universal exploration sequence for a 3-regular graph from above. Therefore
  we take $G$ and transform it to a 3-regular graph on which $A$ finds the
  corresponding universal exploration sequence. The transformation replaces
  any node $v$ with degree $d$ by $3d$ nodes which then form a circle where
  every nodes has degree $3$. The edges of $v$ are moved to nodes in the
  circle. Specifically the edge with port $i$ is replaced by 3 edges which are
  attached to $(v,i), (v,i+d), (v,i+2d)$. (Note that the other
  vertex attached to the edge is replaced by the same construction and therfore
  offers enough ports for the newly introduced edges.) Figure \ref{fig:3reg}
  illustrates this construction.  This simulation yields at most
  $3\Delta n^{2}$ many nodes and can be emulated with $\mathcal{O}(1)$ many
  memory space since it is only needed to store the second component of the
  inserted nodes which is bounded by $3\Delta$. Furthermore $A$ can be run on
  this constructed Graph and only needs $\mathcal{0}(\log n)$ space since
  $\mathcal{O}(\log(3\Delta n^{2})) = \mathcal{O}(\log(3) + \log(\Delta) +
  2\log(n)) = \mathcal{O}(\log n)$. Which yields the desired
  $(\mathcal{O}(1),0,\mathcal{O}(\log n))$ pebble machine.
\end{proof}

In order to obtain the desired boundary of $\log\log n$ space and $\log\log n$
pebbles we show that a pebble machine can be simulated by storing its tape
content by pebbles that are placed on a closed walk.
\begin{thm}
  \label{thm:simulation}
  For every graph $G$ a $(s,p,2m)$ pebble machine $M$ can be simulated by
  a $(cs,p + c,m)$ pebble machine that simulates the walk of $M$ or explores
  $G$.
\end{thm}
\begin{figure}
  \caption{Illustration how to simulate the tape of a pebble machine by
  placing pebbles on a closed walk where $m_{1} = 3$. Note that the first
  $2^{m_{1}}=2^{3}=8$ distinct vertices are used for the simulation but the
  walk can be longer (as indicated by the dotted connection from $7$ to $0$).}
  \label{fig:tapesim}
  \begin{center}
    \resizebox{0.6\textwidth}{!}{\input{tikz/tapesim}}
  \end{center}
\end{figure}
\begin{proof}
  In this proof we will focus on the simulation and we leave out a thorough
  analysis of the space requirements of the simulation since it is rather
  technical but does not add a lot to the idea. Nevertheless we encourage
  interested readers to see \cite{pebbles} for the details.

  The main idea of this simulation is to store the tape of $M$ by pebbles
  placed on a closed walk in the graph. We show that every node on this closed
  walk can be given an index and a pebble placed on a node represents the
  binary representation of the index as the content of $M$'s tape. Therefore we
  first off introduce a variable $m_{1}$ which is dependent on the simulated
  pebble machine $M$ (further requirements on $m_{1}$ and how to obtain it
  can be seen in \cite{pebbles}). We will now take the tape of $M$ and separate
  it into $2m/m_{1}$ blocks of the size $m_{1}$. And each of these blocks is
  encoded by the placement of a pebble on a closed walk $\omega$. So we use
  pebble $p_{0}$ to encode the first $m_{1}$ bits, the pebble $p_{1}$ used to
  encode the next $m_{1}$ bits and so forth. Thus, the pebble $p_{i}$ encodes
  the bits $im_{1},\dots,(i+1)m_{1}-1$. It is therefore necessary that every
  pebble can encode $2^{m_1}$ different states. Therefore we use a closed walk
  $\omega$ which visits at least $2^{m_1}$ distinct vertices yielding $2^{m_1}$
  many \enquote{states} for each pebble (by its placement on this closed walk).
  Therefore we can use the binary representation of the indices of the nodes
  on which the pebbles are placed as the content of the encoded memory block.
  Figure \ref{fig:tapesim} illustrates this.

  In the following we show how this simulation can be managed.
  Let $M_{\text{Walk}}$ be pebble machine that yields $\omega$ on $G$.
  $M_{\text{Walk}}$ can be implemented as $(\mathcal{O}(1),0,\mathcal{m_1})$
  pebble machine by Theorem \ref{thm:pebblewalk}.
  In order to manage the simulation we use some
  variables: $\Tid, \Tsteps, \Twalk, \Thead$ where $\Tid$ is used to identify
  the index of a vertex on the walk of $M_{\text{Walk}}$, $\Twalk$ is the tape
  content of $M_{\text{Walk}}$ which can therefore be restarted by setting
  $\Twalk$ to 0, $\Tsteps$ counts the number of steps taken by
  $M_{\text{Walk}}$, and $\Thead$ stores where $M$'s head is positioned.
  Furthermore we need some pebbles to mark certain vertices of the closed walk:
  $p_{\text{start}}, p_{\text{tmp}}, p_{\text{next}}$ and additionally the
  pebbles that are placed on the walk to store $M$'s tape content
  $P_{M} = \left\{p_{0},p_{1},\dots,p_{2m/m_{1}-1}\right\}$.
  Now the different procedures used for the simulation can be presented:
  \begin{description}
    \item[Step():] Simulates on step according to $M_{\text{Walk}}$ and
      increases $\Tsteps$.
    \item[FindPebble($p_{i}$):] Executes \emph{Step()} until the pebble $p_{i}$
      is observed.
    \item[Restart():] Goes to the beginning of the closed walk by
      \emph{FindPebble($p_{\text{start}}$)} and sets $\Tsteps,\Tid,\Twalk$ to 0
    \item[NextDistinctVertex()] Finds the next distinct vertex of the walk. If
      there are no more vertices on the walk (which means that already
      $2^{m_1}$ distinct vertices have been traversed; the number of distinct
      vertices on the walk is given by $\Tid$) it simply executes
      \emph{Restart()}. Otherwise it does one step and drops $p_{\text{tmp}}$
      to mark this vertex. It then stores the current amount of steps as well
      as the current state of $M_{\text{Walk}}$ (introducing two auxiliary
      variables $\Tsteps',\Twalk'$). It then restarts $M_{\text{Walk}}$ and
      moves to $p_{\text{tmp}}$ by \emph{FindPebble($p_{\text{tmp}}$)}. If
      it used the same amount of steps as stored in $\Tsteps'$ then this is the
      first occurence of the vertex in the closed walk and therefore it is a
      new distinct vertex and $\Tid$ can be increased. Otherwise the context of
      $M_{\text{Walk}}$ is restored and the next vertex is checked.
    \item[GetPebbleId($p_{i}$):] Finds the index of the vertex $p_{i}$ is
      placed on. Beginning from the start of the closed walk
      (found by executing \emph{Restart()} it moves along distinct vertices
      (by using \emph{NextDistinctVertex()}) and returns $\Tid$ as soon as
      $p_{i}$ is observed.
    \item[PutPebbleAtId($p_{i},\mathit{id}$):] Puts pebble $p_i$ at a certain
      index. First it picks up $p_{i}$ and restarts the walk. Then it executes
      $\mathit{id}$ times \emph{NextDistinctVertex()} and drops $p_{i}$.
    \item[ReadBit():] Reads the $\Thead$'s bit of $M$'s tape. $\Thead$ gives
      the position of the bit that should be read. Therefore the pebble
      $p_{\lfloor \Thead/m_{1}\rfloor}$ encodes this bit. The \enquote{state}
      of this pebble can be obtained with
      \emph{GetPebbleId($p_{\lfloor \Thead/m_{1}\rfloor}$)} and from the
      encoded value the $(\Thead\mod m_{1})$-th bit is the one under $M$'s
      head.
    \item[WriteBit($b$):] Writes $b$ to $\Thead$'s bit of $M$'s tape. First
      $\Thead$'s bit is obtained (by \emph{ReadBit()}). Additionally we
      identify the encoding pebble $p_{i}$ as already seen for
      \emph{ReadBit()} and let be $j = \Thead\mod m_{1}$ the offset of the bit
      within the memory block. If the bit actually flips the value of the
      memory block changes by $2^j$ (for the flip from 1 to 0 the value
      decreases and for the flip from 0 to 1 it increases). Therefore $p_{i}$
      is put either $2^j$ indices up or down which can be easily done by using
      \emph{PutPebbleAtId(\dots)}.
  \end{description}
  These are the procedures used to simulate $M$'s tape. Furthermore we keep
  $M$'s states in the state space of the simulation. To conclude the simulation
  we have to consider what happens if $M$ moves from the current vertex to
  another vertex $v'$. Then the pebble $p_{tmp}$ is dropped on $v'$ and the
  pebbles are moved to the same index they have in $\omega$ for a new closed
  walk $\omega'$ (obtained by $M_{\text{Walk}}$ simulated starting in $v'$;
  this walk is also ensured to have at least $2^{m_1}$ distinct vertices).
\end{proof}
As Theorem \ref{thm:pebblewalk} yields a $(c,0,c\cdot\log n)$ pebble machine
that explores a given graph we can now repeatedly apply the simulation
from Theorem \ref{thm:simulation} (precisely $\log\log n$ times) and end up
with a $(c'^{\log\log n}\cdot c, \log\log n\cdot c',
\frac{c}{2^{\log\log n}}\log n) =
(c'^{\log\log n}\cdot c, \log\log n\cdot c', c)$ pebble machine exploring the
graph.

\section{Barriers}
In the following we will discuss the limits of the exploration approach with
pebbles. Specifically, we will argue that we can construct 3-regular graphs
that any agent with $p$ pebbles cannot traverse. Such graphs are called
$p$-barriers.
Note that connecting a 3-regular graph might violate its 3-regularity.
Therefore we rely on having a distinguishable edge $e$ in the 3-regular graph
which we can delete to connect the vertices $e$ connected to the
\enquote{outside}. This preserves the 3-regularity. The interested reader might
then enjoy the following exercise:
\begin{ex}
  Given a $p$-barrier with $m$ vertices for a agent $A$ with $p$ pebbles.
  Construct a trap for $A$ (with $2m+4$ vertices). 
\end{ex}

The construction of barriers is inductively and therefore requires that the
base case can be constructed directly. Fortunately Theorem 4 in \cite{0barrier}
yields a graph which can be adapted by connecting two identical copies to a
0-barrier (for details we refer again to \cite{pebbles}). With this in mind we
introduce a gadget construction for a given $r$-barrier $B$ as it can be seen
in figure \ref{fig:gadget}\todo{add figure}. Replacing edges of a graph with
such gadgets enforces, in a sense, \enquote{locality} of pebbles. We call
the verices that are connected by the gadget macro-vertices and if a $r+1$
pebble machine stands on a macro vertex we can safely be assured that all
pebbles are either carried by the agent or are placed within the adjacent
gadgets because otherwise the agent has left a pebble across of an $r$-barrier
and crossed the barrier with $r$ pebbles contradicting that it is in fact an
$r$-barrier. This observation can be used to construct an $r$-barrier given
a $(r-1)$-barrier is known.
\begin{thm}
  With a given $(r-1)$-barrier for an agent $A$ a $r$-barrier can be
  constructed.
\end{thm}
\begin{proof}
  We will present only the key ideas of this proof since it involves a
  few technicalities which do not add much to the general understanding
  and are therefore omitted. Given a subset of pebbles of cardinality $r$
  we can construct an $r$-barrier for this subset by using the given
  $(r-1)$-barrier to enforce locality of the pebbles. We can then project
  $A$'s behaviour to an agent $B$ which is a pebble machine without pebbles
  and has a state for every configuration (which includes the placing of the
  pebbles as well as state and tape content) of $A$. $B$ now moves over the
  macro-vertices as $A$ moves through the gadgets. But $B$ has no pebbles and
  thus, it is applicable to the 0-barrier. Projecting this construct back to
  the gadget construction yields an $r$-barrier for $A$ and the chosen subset
  of pebbles. Connecting now such $r$-barriers for all possible subsets of
  pebbles gives the desired $r$-barrier because $A$ always fails to traverse
  the $r$-barrier particular constructed for the pebble set used by $A$.
\end{proof}
By constructing such barriers it is possible to find for every agent
with $s$ states and $p$ pebbles (note that here the tape of the agent is
encoded in the states) it is possible to give a trap where the amount of
vertices can be bound by $\mathcal{O}(s^{8^{p+1}})$. Which can be used to
show that every agent with sub-logarithmic bits of memory needs at least
$\Omega(\log\log n)$ many pebbles to explore at least $n$ vertices.

\setquotestyle{english}
\printbibliography
\end{document}
