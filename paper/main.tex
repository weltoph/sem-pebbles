\documentclass[draft,oneside]{scrartcl}

\usepackage[utf8]{inputenc}

\usepackage{epigraph}
\usepackage[autostyle,german=guillemets]{csquotes}
\usepackage[ngerman, english]{babel}
\usepackage[style=numeric,backend=biber]{biblatex}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{todonotes}
\usepackage{mdframed}
\usepackage{wrapfig}

\newtheorem{thm}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lem}{Lemma}
\newtheorem{prop}{Proposition}

\addbibresource{bibliography.bib}

\DeclareMathOperator{\din}{\delta_{\mathit{in}}}
\DeclareMathOperator{\dout}{\delta_{\mathit{out}}}
\DeclareMathOperator{\Tid}{T_{\text{id}}}
\DeclareMathOperator{\Tsteps}{T_{\text{steps}}}
\DeclareMathOperator{\Twalk}{T_{\text{walk}}}
\DeclareMathOperator{\Thead}{T_{\text{head}}}

\input{tikz/settings}

\begin{document}


\setlength{\epigraphwidth}{0.7\textwidth}
\setquotestyle{german}

\title{Exploring graphs with pebbles}
\subtitle{A \emph{Grimm} idea}
\author{Christoph Welzel}
\maketitle

\epigraph{Und als der volle Mond aufgestiegen war, so nahm Hänsel sein %
Schwesterchen an der Hand und ging den Kieselsteinen nach, die schimmerten %
wie neu geschlagene Batzen und zeigten ihnen den Weg.}%
{\emph{Hänsel und Gretel}\\Brüder Grimm}

\setquotestyle{english}
\section{Introduction}

\section{Preliminaries}
For the further course we assume the following: Firstly, the considered
graphs are finite but huge. The considered agents have limited memory and can
therefore not compute the identifier of vertices. This makes all vertices
indistinguishable for the agents. Also, the degree of the vertices is bounded
by a constant $\Delta$. For every vertex $v$ we assume that the connected edges
can be locally enumerated with labels $0,\dots,d_{v} - 1$ where $d_{v}$ is the
degree of $v$. These edge-labels are called ports and every edge has one port
for both vertices it connects. Note that there is no relation between these
ports is presumed.

\section{Graph exploration}
We begin this section by formally defining our agents in the form of
\emph{pebble machines}. This definition closely follows the notion of Turing
machines but adds mechanisms to model the movements of the agent.
\begin{definition}[Pebble machine]
  A $(s,p,m)$-\emph{pebble machine} $\mathcal{M}$ is defined as a tuple
  $(Q,F,P,m,\delta,\din,\dout,q_{0})$. Here we have
  \begin{enumerate}
    \item a finite set of states $Q$ with cadinality $s$
    \item a finite set of final states $F\subseteq Q$
    \item a finite set of distinguishable pebbles $P$ with cardinality $p$
    \item the length of the available memory tape $m$
    \item a computation function $\delta$
    \item a function that describes the movement onto a vertex
      $\din$
    \item a function that describes the leaving of a vertex $\dout$
    \item an inital state $q_{0}$
  \end{enumerate}
  where formally the computation function models the behaviour of the pebble
  machine as
  \begin{equation*}
    \delta\colon (Q\setminus F)\times\left\{0,1\right\}\rightarrow
    Q\times\left\{0,1\right\}\times\left\{L,R\right\}
  \end{equation*}
  with the typical understanding of the computation of a Turing machine.
  Furthermore
  \begin{equation*}
    \din\colon Q\times 2^{P}\times 2^{P}\times
    \left\{0,\dots,\Delta - 1\right\}\times\left\{0,\dots,\Delta - 1\right\}
    \rightarrow Q
  \end{equation*}
  models how a pebble machine moves upon a vertex $v$ with
  $\din(q,P_{1},P_{2},d,\ell) = q'$ where $q$ is the current state of
  $\mathcal{M}$, $P_{1}$ the set of pebbles it carries, $P_{2}$ the set
  of pebbles located on $v$, $d$ is the degree of $v$ and $\ell$ the port
  through which $\mathcal{M}$ enters $v$. Then $\mathcal{M}$ starts its
  computation according to $\delta$ in state $q'$.

  $\dout$ is defined as
  \begin{equation*}
    \dout\colon Q
    \rightarrow 2^{P}\times 2^{P}\times \left\{0,\dots,\Delta - 1\right\}
  \end{equation*}
  where $\dout(q) = (P_{1}, P_{2}, \ell)$ defines that $\mathcal{M}$ leaves
  a vertex $v$ through port $\ell$ dropping the pebbles in $P_{1}$ onto $v$
  and carrying the pebble in $P_{2}$.

  We additionally demand consistency of pebbles, i.e. that if the agent
  carried the pebbles in $P_{1}\subseteq P$ and found the pebbles in
  $P_{2}\subseteq P$ it is necessary that $P_{1}$ and $P_{2}$ are disjoint and
  furthermore that if the agent leaves carrying $P'_{1}$ and leaving $P'_{2}$
  behind those sets are disjoint and $P_{1}\cup P_{2} = P'_{1}\cup P'_{2}$.
\end{definition}

In order to describe the movement of an agent we introduce the notion of an
exploration sequence as $e_{0}, e_{1},\dots$ which define relative movements:
Let $\ell = \ell_{0},\ell_{1},\dots$ be a sequence of variables where
$\ell_{i}$ denotes the port which a vertex $v$ was entered through. Then an
agent following $\ell$ leaves through port
$(\ell_{i} + e_{i}) \mod d_{v}$. We define $\ell_{0} = 0$ and the notion
$(e_{0},\dots,e_{k})^{\ast}$ for periodic exploration sequence.

Beginning from the following result of \cite{logspacealg} we present how we can
obtain an $(\mathcal{O}(1),0,\mathcal{O}(\log n))$ pebble machine that walks
along a closed walk of at least $n$ distinct vertices in any graph with bounded
degree.
\begin{thm}[Reingold]
  \label{thm:logalg}
  There is an $\mathcal{O}(\log n)$-space algorithm producing a universal
  exploration sequence for any regular graph on $n$ vertices.
\end{thm}

We can now find the $(\mathcal{O}(1),0,\mathcal{O}(\log n))$ pebble machine we
are looking for.
\begin{thm}
  \label{thm:pebblewalk}
  There is a $(\mathcal{O}(1),0,\mathcal{O}(\log n))$ pebble machine which
  explores every given graph $G$ with bounded degree $\Delta$ either completly
  or at least loops on $n$ distinct vertices.
\end{thm}
\begin{wrapfigure}{r}{0.5\textwidth}
  \caption{Illustration how to transform any graph to a 3-regular graph.}
  \label{fig:3reg}
  \resizebox{0.5\textwidth}{!}{\input{tikz/regtrans}}
\end{wrapfigure}
\begin{proof}
  The main idea is to use the adapted algorithm $A$ to find for an
  universal exploration sequence for a 3-regular graph from above. Therefore
  we take $G$ and transform it to a 3-regular graph on which $A$ finds the
  corresponding universal exploration sequence. The transformation replaces
  any node $v$ with degree $d$ by $3d$ nodes which then form a circle where
  every nodes has degree $3$. The edges of $v$ are moved to nodes in the
  circle. Specifically the edge with port $i$ is replaced by 3 edges which are
  attached to $(v,i), (v,i+d), (v,i+2d)$. (Note that the other
  vertex attached to the edge is replaced by the same construction and therfore
  offers enough ports for the newly introduced edges.) Figure \ref{fig:3reg}
  illustrates this construction.  This simulation yields at most
  $3\Delta n^{2}$ many nodes and can be emulated with $\mathcal{O}(1)$ many
  memory space since it is only needed to store the second component of the
  inserted nodes which is bounded by $3\Delta$. Furthermore $A$ can be run on
  this constructed Graph and only needs $\mathcal{0}(\log n)$ space since
  $\mathcal{O}(\log(3\Delta n^{2})) = \mathcal{O}(\log(3) + \log(\Delta) +
  2\log(n)) = \mathcal{O}(\log n)$. Which yields the desired
  $(\mathcal{O}(1),0,\mathcal{O}(\log n))$ pebble machine.
\end{proof}

In order to obtain the desired boundary of $\log\log n$ space and $\log\log n$
pebbles we show that a pebble machine can be simulated by storing its tape
content by pebbles that are placed on a closed walk.
\begin{thm}
  \label{thm:simulation}
  For every graph $G$ a $(s,p,2m)$ pebble machine $M$ can be simulated by
  a $(cs,p + c,m)$ pebble machine that simulates the walk of $M$ or explores
  $G$.
\end{thm}
\begin{proof}
  In this proof we will focus on the simulation and we leave out a thorough
  analysis of the space requirements of the simulation since it is rather
  technical but does not add a lot to the idea. Nevertheless we encourage
  interested readers to see \cite{pebbles} for the details.

  The main idea of this simulation is to store the tape of $M$ by pebbles
  placed on a closed walk in the graph. We show that every node on this closed
  walk can be given an index and a pebble placed on a node represents the
  binary representation of the index as the content of $M$'s tape. Therefore we
  first off introduce a variable $m_{1}$ which is dependent on the simulated
  pebble machine $M$ (further requirements on $m_{1}$ and how to obtain it
  can be seen in \cite{pebbles}). We will now take the tape of $M$ and separate
  it into $2m/m_{1}$ blocks of the size $m_{1}$. And each of these blocks is
  encoded by the placement of a pebble on a closed walk $\omega$. So we use
  pebble $p_{0}$ to encode the first $m_{1}$ bits, the pebble $p_{1}$ used to
  encode the next $m_{1}$ bits and so forth. Thus, the pebble $p_{i}$ encodes
  the bits $im_{1},\dots,(i+1)m_{1}-1$. It is therefore necessary that every
  pebble can encode $2^{m_1}$ different states. Therefore we use a closed walk
  $\omega$ which visits at least $2^{m_1}$ distinct vertices yielding $2^{m_1}$
  many \enquote{states} for each pebble (by its placement on this closed walk).
  Therefore we can use the binary representation of the indices of the nodes
  on which the pebbles are placed as the content of the encoded memory block.
  Figure \ref{fig:tapesim} illustrates this.
  \begin{figure}[h!]
    \caption{Illustration how to simulate the tape of a pebble machine by
      placing pebbles on a closed walk where $m_{1} = 3$. Note that the first
      $2^{m_{1}}=2^{3}=8$ distinct vertices are used for the simulation but the
    walk can be longer (as indicated by the dotted connection from $7$ to $0$).}
    \label{fig:tapesim}
    \begin{center}
      \resizebox{0.6\textwidth}{!}{\input{tikz/tapesim}}
    \end{center}
  \end{figure}

  In the following we show how this simulation can be managed.
  Let $M_{\text{Walk}}$ be pebble machine that yields $\omega$ on $G$.
  $M_{\text{Walk}}$ can be implemented as $(\mathcal{O}(1),0,\mathcal{O}(m_{1}))$
  pebble machine by Theorem \ref{thm:pebblewalk}.
  In order to manage the simulation we use some
  variables: $\Tid, \Tsteps, \Twalk, \Thead$ where $\Tid$ is used to identify
  the index of a vertex on the walk of $M_{\text{Walk}}$, $\Twalk$ is the tape
  content of $M_{\text{Walk}}$ which can therefore be restarted by setting
  $\Twalk$ to 0, $\Tsteps$ counts the number of steps taken by
  $M_{\text{Walk}}$, and $\Thead$ stores where $M$'s head is positioned.
  Furthermore we need some pebbles to mark certain vertices of the closed walk:
  $p_{\text{start}}, p_{\text{tmp}}, p_{\text{next}}$ and additionally the
  pebbles that are placed on the walk to store $M$'s tape content
  $P_{M} = \left\{p_{0},p_{1},\dots,p_{2m/m_{1}-1}\right\}$.
  Now the different procedures used for the simulation can be presented:
  \begin{description}
    \item[Step():] Simulates on step according to $M_{\text{Walk}}$ and
      increases $\Tsteps$.
    \item[FindPebble($p_{i}$):] Executes \emph{Step()} until the pebble $p_{i}$
      is observed.
    \item[Restart():] Goes to the beginning of the closed walk by
      \emph{FindPebble($p_{\text{start}}$)} and sets $\Tsteps,\Tid,\Twalk$ to 0
    \item[NextDistinctVertex()] Finds the next distinct vertex of the walk. If
      there are no more vertices on the walk (which means that already
      $2^{m_1}$ distinct vertices have been traversed; the number of distinct
      vertices on the walk is given by $\Tid$) it simply executes
      \emph{Restart()}. Otherwise it does one step and drops $p_{\text{tmp}}$
      to mark this vertex. It then stores the current amount of steps as well
      as the current state of $M_{\text{Walk}}$ (introducing two auxiliary
      variables $\Tsteps',\Twalk'$). It then restarts $M_{\text{Walk}}$ and
      moves to $p_{\text{tmp}}$ by \emph{FindPebble($p_{\text{tmp}}$)}. If
      it used the same amount of steps as stored in $\Tsteps'$ then this is the
      first occurence of the vertex in the closed walk and therefore it is a
      new distinct vertex and $\Tid$ can be increased. Otherwise the context of
      $M_{\text{Walk}}$ is restored and the next vertex is checked.
    \item[GetPebbleId($p_{i}$):] Finds the index of the vertex $p_{i}$ is
      placed on. Beginning from the start of the closed walk
      (found by executing \emph{Restart()} it moves along distinct vertices
      (by using \emph{NextDistinctVertex()}) and returns $\Tid$ as soon as
      $p_{i}$ is observed.
    \item[PutPebbleAtId($p_{i},\mathit{id}$):] Puts pebble $p_i$ at a certain
      index. First it picks up $p_{i}$ and restarts the walk. Then it executes
      $\mathit{id}$ times \emph{NextDistinctVertex()} and drops $p_{i}$.
    \item[ReadBit():] Reads the $\Thead$'s bit of $M$'s tape. $\Thead$ gives
      the position of the bit that should be read. Therefore the pebble
      $p_{\lfloor \Thead/m_{1}\rfloor}$ encodes this bit. The \enquote{state}
      of this pebble can be obtained with
      \emph{GetPebbleId($p_{\lfloor \Thead/m_{1}\rfloor}$)} and from the
      encoded value the $(\Thead\mod m_{1})$-th bit is the one under $M$'s
      head.
    \item[WriteBit($b$):] Writes $b$ to $\Thead$'s bit of $M$'s tape. First
      $\Thead$'s bit is obtained (by \emph{ReadBit()}). Additionally we
      identify the encoding pebble $p_{i}$ as already seen for
      \emph{ReadBit()} and let be $j = \Thead\mod m_{1}$ the offset of the bit
      within the memory block. If the bit actually flips the value of the
      memory block changes by $2^j$ (for the flip from 1 to 0 the value
      decreases and for the flip from 0 to 1 it increases). Therefore $p_{i}$
      is put either $2^j$ indices up or down which can be easily done by using
      \emph{PutPebbleAtId(\dots)}.
  \end{description}
  These are the procedures used to simulate $M$'s tape. Furthermore we keep
  $M$'s states in the state space of the simulation. To conclude the simulation
  we have to consider what happens if $M$ moves from the current vertex to
  another vertex $v'$. Then the pebble $p_{tmp}$ is dropped on $v'$ and the
  pebbles are moved to the same index they have in $\omega$ for a new closed
  walk $\omega'$ (obtained by $M_{\text{Walk}}$ simulated starting in $v'$;
  this walk is also ensured to have at least $2^{m_1}$ distinct vertices).
\end{proof}
As Theorem \ref{thm:pebblewalk} yields a $(c,0,c\cdot\log n)$ pebble machine
that explores a given graph we can now repeatedly apply the simulation
from Theorem \ref{thm:simulation} (precisely $\log\log n$ times) and end up
with a $(c'^{\log\log n}\cdot c, \log\log n\cdot c',
\frac{c}{2^{\log\log n}}\log n) =
(c'^{\log\log n}\cdot c, \log\log n\cdot c', c)$ pebble machine exploring the
graph.

\section{Barriers}
In the following we will discuss the limits of the exploration approach with
pebbles. Specifically, we will argue that we can construct 3-regular graphs
that any agent with $p$ pebbles cannot traverse. Such graphs are called
$p$-barriers.
Note that connecting a 3-regular graph might violate its 3-regularity.
Therefore we rely on having a distinguishable edge $e$ in the 3-regular graph
which we can delete to connect the vertices $e$ connected to the
\enquote{outside}. This preserves the 3-regularity. The interested reader might
then enjoy the following exercise:
\begin{prop}
  Given a $p$-barrier with $m$ vertices for a agent $A$ with $p$ pebbles.
  Construct a trap for $A$ (with $2m+4$ vertices). 
\end{prop}

\begin{wrapfigure}{r}{0.4\textwidth}
  \caption{Gadget construction that ensures locality of pebbles.}
  \label{fig:gadget}
  \resizebox{0.4\textwidth}{!}{\input{tikz/gadget}}
\end{wrapfigure}
The construction of barriers is inductively and therefore requires that the
base case can be constructed directly. Fortunately Theorem 4 in \cite{0barrier}
yields a graph which can be adapted to a 0-barrier. With this in mind we
introduce a gadget construction for a given $r$-barrier $B$ as it can be seen
in Figure \ref{fig:gadget}. Replacing edges of a graph with
such gadgets enforces, in a sense, \enquote{locality} of pebbles. We call
the verices that are connected by the gadget macro-vertices and if a $r+1$
pebble machine stands on a macro vertex we can safely be assured that all
pebbles are either carried by the agent or are placed within the adjacent
\enquote{edges} because otherwise the agent has left a pebble across of an
$r$-barrier and crossed the barrier with $r$ pebbles contradicting that it is
in fact an $r$-barrier. This observation can be used to construct an
$r$-barrier given a $(r-1)$-barrier is known.
\begin{thm}
  With a given $(r-1)$-barrier for an agent $A$ a $r$-barrier can be
  constructed.
\end{thm}
\begin{proof}
  We will present only the key ideas of this proof since it involves a
  few technicalities which do not add much to the general understanding
  and are therefore omitted. Given a subset of pebbles of cardinality $r$
  we can construct an $r$-barrier for this subset by using the given
  $(r-1)$-barrier. By the above described gadget construction we can enforce
  the locality of the used $r$ pebbles. We can then project
  $A$'s behaviour to an agent $B$ which is a pebble machine without pebbles
  and has a state for every configuration (which includes the placing of the
  pebbles as well as state and tape content) of $A$. $B$ now moves over the
  macro-vertices as $A$ moves through the gadgets. But $B$ has no pebbles and
  thus, it is applicable to the 0-barrier. Projecting this construct back to
  the gadget construction yields an $r$-barrier for $A$ and the chosen subset
  of pebbles. Connecting now such $r$-barriers for all possible subsets of
  pebbles gives the desired $r$-barrier because $A$ always fails to traverse
  the $r$-barrier particularly constructed for the pebble set used by $A$.
\end{proof}
By constructing such barriers it is possible to find for every agent
with $s$ states and $p$ pebbles (note that here the tape of the agent is
encoded in the states) it is possible to give a trap where the amount of
vertices can be bound by $\mathcal{O}(s^{8^{p+1}})$. Which can be used to
show that every agent with sub-logarithmic bits of memory needs at least
$\Omega(\log\log n)$ many pebbles to explore at least $n$ vertices.

\section{Conclusion}
In this paper re-presented the idea of pebble machines for graph exploration
as discussed in \cite{pebbles}. For this we focused on conwaying the essential
ideas and constructions rather than explore the technical details. The main
result clearly is the simulation of memory of pebble machines by encoding
memory blocks by pebbles and that these pebbles keep a state by their placement
along a closed walk.

\setquotestyle{english}
\printbibliography
\end{document}
