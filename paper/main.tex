\documentclass[draft,oneside]{scrartcl}

\usepackage[utf8]{inputenc}

\usepackage{epigraph}
\usepackage[autostyle,german=guillemets]{csquotes}
\usepackage[ngerman, english]{babel}
\usepackage[style=numeric,backend=biber]{biblatex}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{todonotes}

\addbibresource{bibliography.bib}

\DeclareMathOperator{\din}{\delta_{\mathit{in}}}
\DeclareMathOperator{\dout}{\delta_{\mathit{out}}}

\begin{document}

\setlength{\epigraphwidth}{0.7\textwidth}
\setquotestyle{german}

\title{A \emph{Grimm} idea}
\subtitle{Exploring graphs with pebbles}
\author{Christoph Welzel}
\maketitle

\begin{abstract}
  In this paper we re-present and explain an approach on exploring large
  undirected graphs with the help of markers, so called pebbles, for vertices.
  We focus on the central ideas of this approach and explain why it is possible
  to traverse any graph with $n$ vertices with $\Theta(\log \log n)$ pebbles
  and the same amount of memory.
\end{abstract}

\epigraph{Und als der volle Mond aufgestiegen war, so nahm Hänsel sein %
Schwesterchen an der Hand und ging den Kieselsteinen nach, die schimmerten %
wie neu geschlagene Batzen und zeigten ihnen den Weg.}%
{\emph{Hänsel und Gretel}\\Brüder Grimm}

\setquotestyle{english}
\section{Introduction}
Traversing large graphs is an interesting challenge. In times of the internet
web crawlers have to traverse immense graphs but also regarding complexity
theory this is an interesting problem. First we will informally introduce two
complexity classes to illustrate the importance of graph traversal from a
complexity point of view: $L$ as the class of problems that can be solved by
a deterministic Turing machine with additional memory of logarithmic amount
of the input. And $SL$ as the class of problems that can be solved with the
same space requirements but by a non-deterministic symmetrical Turing machine,
where symmetrical means that for every computation step of the Turing machine
there is a computation step to undo the previous one. As it turns out checking
if two vertices $s$ and $t$ are connected in an undirected graph is a problem
that is complete for $SL$. This problem is often refered to as
$\mathrm{USTCON}$ and \citeauthor{logspacealg} showed in \cite{logspacealg}
that $\mathrm{USTCON}\in L$ which collapsed $SL$ into $L$, hence $SL = L$.
In the following we will present the results from \cite{pebbles} where another
mechanism of graph exploration is used: with the use of pebbles which are small
pieces of memory that can be dropped on and collected from the vertex as an
agent traverses the graph. As we will show it is possible to traverse a graph
with $n$ vertices with $\mathcal{O}(\log\log n)$ memory and the same amount of
pebbles. Furthermore we will explain why there is no smaller amount of memory
or pebbles to generally obtain the same guarantee to traverse all $n$ vertices.

\section{Preliminaries}
For the course of this paper we assume the following: Firstly, the vertices can
not be distinguished by the traversing agent. But as the agent moves on a
vertex it can compute its degree. Secondly, the edges attached to the vertex
can be locally distinguished and are enumerated with the indices
$\left\{0,\dots,d_{v}-1\right\}$ where $d_{v}$ denotes the degree of the vertex
$v$. We refer to the \enquote{index} of the edge as its \emph{port}. Note that
every edge thus has two different ports and furthermore that there is no
relation between the ports is assumed. Additionally the degree of the
considered graphs are assumed to be limited by a constant $\Delta$ and that
there are only a finite amount of vertices.

\section{Pebble machines}
We are now ready to introduce the model of pebble machines formally. It closely
follows the notion of Turing machines but adds mechanisms to model the
movements of the agent. The presented model of pebble machines thus have
\begin{enumerate}
  \item a finite set of states $Q$
  \item a finite set of final states $F\subseteq Q$
  \item a finite set of distinguishable pebbles $P$
  \item a length of the used memory tape $m$
  \item a computation function $\delta$
  \item a function that describes the movement onto a vertex
    $\din$
  \item a function that describes the leaving of a vertex $\dout$
  \item an inital state $q_{0}$
\end{enumerate}
where formally the computation function models the behaviour of the pebble
machine as follows:
\begin{equation*}
  \delta\colon (Q\setminus F)\times\left\{0,1\right\}\rightarrow
  Q\times\left\{0,1\right\}\times\left\{L,R\right\}
\end{equation*}
with the typical understanding of the computation of a Turing machine.
As an agent traverses a vertex it is aware of the pebbles it carries
around, it observes the set of pebbles on the vertex and the degree of the
vertex and it furthermore aware of the port that it entered through.
Thus we use
\begin{equation*}
  \din\colon Q\times 2^{P}\times 2^{P}\times
  \left\{0,\dots,\Delta - 1\right\}\times\left\{0,\dots,\Delta - 1\right\}
  \rightarrow Q
\end{equation*}
to model this behaviour. And finally as the agent leaves a vertex it leaves
a set of pebbles behind, picks up another set and chooses the port it leaves
through. We choose to model this behaviour as
\begin{equation*}
  \dout\colon Q
  \rightarrow 2^{P}\times 2^{P}\times \left\{0,\dots,\Delta - 1\right\}
\end{equation*}
Of course we also demand consistency of the pebbles, i.e. that if the agent
carried $P_{1}\subseteq P$ and found $P_{2}\subseteq P$ it is necessary that
$P_{1}$ and $P_{2}$ are disjoint and furthermore that if the agent leaves
carrying $P'_{1}$ and leaving $P'_{2}$ behind those sets are disjoint and
$P_{1}\cup P_{2} = P'_{1}\cup P'_{2}$.

In order to describe the movement of an agent we introduce the notion of an
exploration sequence as $e_{0}, e_{1},\dots$ which models relative movements
as follows. We use a sequence of variables $l_{0},l_{1},\dots$ which denotes
the port a vertex was entered through. And the next vertex is determined as the
one connected to the port $(l_{i} + e_{i}) \mod d_{v_{i}}$. We define
$l_{0} = 0$ and the notion $(e_{0},\dots,e_{k})^{\ast}$ for periodic sequences.
It can be shown that a periodic sequence produces a closed walk through a
graph. Therefore we argue that there is only a finite amount of triples of the
form $(v,l,i)$ exists where currently the agent is on vertex $v$, entered this
vertex through port $l$ and is currently at index $i$ of the exploration
sequence. For two triples $(v',l',i')$ and $(v'',l'',i'')$ that both lead to
$(v,l,i)$ it is easy to see, that $(v',l',i') = (v'',l'',i'')$. Thus, for every
triple there is a unique predecessor and successor which implies due to the
finiteness of the triples $(v,l,i)$ and that the agent moves infinitely it
follows that the first triple has to be valid infinitly often. This means a
periodic exploration sequence yields a closed walk. \todo{maybe enclose in
proof environment}

One result of \cite{logspacealg} states: 
\todo{add theorem boxes and definition boxes}

There is an algorithm $M\in L$ which produces a universal exploration sequence
for every regular graph with $n$ vertices.

From which we can conclude very easily the following Lemma which produces a
universal exploration sequence 


\setquotestyle{english}
\printbibliography
\end{document}
