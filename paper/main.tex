\documentclass[draft,oneside]{scrartcl}

\usepackage[utf8]{inputenc}

\usepackage{epigraph}
\usepackage[autostyle,german=guillemets]{csquotes}
\usepackage[ngerman, english]{babel}
\usepackage[style=numeric,backend=biber]{biblatex}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{todonotes}

\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}

\addbibresource{bibliography.bib}

\DeclareMathOperator{\din}{\delta_{\mathit{in}}}
\DeclareMathOperator{\dout}{\delta_{\mathit{out}}}
\DeclareMathOperator{\Tid}{T_{\text{id}}}
\DeclareMathOperator{\Tsteps}{T_{\text{steps}}}
\DeclareMathOperator{\Twalk}{T_{\text{walk}}}
\DeclareMathOperator{\Thead}{T_{\text{head}}}

\begin{document}

\setlength{\epigraphwidth}{0.7\textwidth}
\setquotestyle{german}

\title{A \emph{Grimm} idea}
\subtitle{Exploring graphs with pebbles}
\author{Christoph Welzel}
\maketitle

\begin{abstract}
  In this paper we re-present and explain an approach on exploring large
  undirected graphs with the help of markers, so called pebbles, for vertices.
  We focus on the central ideas of this approach and explain why it is possible
  to traverse any graph with $n$ vertices with $\Theta(\log \log n)$ pebbles
  and the same amount of memory.
\end{abstract}

\epigraph{Und als der volle Mond aufgestiegen war, so nahm Hänsel sein %
Schwesterchen an der Hand und ging den Kieselsteinen nach, die schimmerten %
wie neu geschlagene Batzen und zeigten ihnen den Weg.}%
{\emph{Hänsel und Gretel}\\Brüder Grimm}

\setquotestyle{english}
\section{Introduction}
Traversing large graphs is an interesting challenge. In times of the internet
web crawlers have to traverse immense graphs but also regarding complexity
theory this is an interesting problem. First we will informally introduce two
complexity classes to illustrate the importance of graph traversal from a
complexity point of view: $L$ as the class of problems that can be solved by
a deterministic Turing machine with additional memory of logarithmic amount
of the input. And $SL$ as the class of problems that can be solved with the
same space requirements but by a non-deterministic symmetrical Turing machine,
where symmetrical means that for every computation step of the Turing machine
there is a computation step to undo the previous one. As it turns out checking
if two vertices $s$ and $t$ are connected in an undirected graph is a problem
that is complete for $SL$. This problem is often refered to as
$\mathrm{USTCON}$ and \citeauthor{logspacealg} showed in \cite{logspacealg}
that $\mathrm{USTCON}\in L$ which collapsed $SL$ into $L$, hence $SL = L$.
In the following we will present the results from \cite{pebbles} where another
mechanism of graph exploration is used: with the use of pebbles which are small
pieces of memory that can be dropped on and collected from the vertex as an
agent traverses the graph. As we will show it is possible to traverse a graph
with $n$ vertices with $\mathcal{O}(\log\log n)$ memory and the same amount of
pebbles. Furthermore we will explain why there is no smaller amount of memory
or pebbles to generally obtain the same guarantee to traverse all $n$ vertices.

\section{Preliminaries}
For the course of this paper we assume the following: Firstly, the vertices can
not be distinguished by the traversing agent. But as the agent moves on a
vertex it can compute its degree. Secondly, the edges attached to the vertex
can be locally distinguished and are enumerated with the indices
$\left\{0,\dots,d_{v}-1\right\}$ where $d_{v}$ denotes the degree of the vertex
$v$. We refer to the \enquote{index} of the edge as its \emph{port}. Note that
every edge thus has two different ports and furthermore that there is no
relation between the ports is assumed. Additionally the degree of the
considered graphs are assumed to be limited by a constant $\Delta$ and that
there are only a finite amount of vertices.

\section{Pebble machines}
We are now ready to introduce the model of pebble machines formally. It closely
follows the notion of Turing machines but adds mechanisms to model the
movements of the agent. The presented model of pebble machines thus have
\begin{enumerate}
  \item a finite set of states $Q$
  \item a finite set of final states $F\subseteq Q$
  \item a finite set of distinguishable pebbles $P$
  \item a length of the used memory tape $m$
  \item a computation function $\delta$
  \item a function that describes the movement onto a vertex
    $\din$
  \item a function that describes the leaving of a vertex $\dout$
  \item an inital state $q_{0}$
\end{enumerate}
where formally the computation function models the behaviour of the pebble
machine as follows:
\begin{equation*}
  \delta\colon (Q\setminus F)\times\left\{0,1\right\}\rightarrow
  Q\times\left\{0,1\right\}\times\left\{L,R\right\}
\end{equation*}
with the typical understanding of the computation of a Turing machine.
As an agent traverses a vertex it is aware of the pebbles it carries
around, it observes the set of pebbles on the vertex and the degree of the
vertex and it furthermore aware of the port that it entered through.
Thus we use
\begin{equation*}
  \din\colon Q\times 2^{P}\times 2^{P}\times
  \left\{0,\dots,\Delta - 1\right\}\times\left\{0,\dots,\Delta - 1\right\}
  \rightarrow Q
\end{equation*}
to model this behaviour. And finally as the agent leaves a vertex it leaves
a set of pebbles behind, picks up another set and chooses the port it leaves
through. We choose to model this behaviour as
\begin{equation*}
  \dout\colon Q
  \rightarrow 2^{P}\times 2^{P}\times \left\{0,\dots,\Delta - 1\right\}
\end{equation*}
Of course we also demand consistency of the pebbles, i.e. that if the agent
carried $P_{1}\subseteq P$ and found $P_{2}\subseteq P$ it is necessary that
$P_{1}$ and $P_{2}$ are disjoint and furthermore that if the agent leaves
carrying $P'_{1}$ and leaving $P'_{2}$ behind those sets are disjoint and
$P_{1}\cup P_{2} = P'_{1}\cup P'_{2}$.

In order to describe the movement of an agent we introduce the notion of an
exploration sequence as $e_{0}, e_{1},\dots$ which models relative movements
as follows. We use a sequence of variables $l_{0},l_{1},\dots$ which denotes
the port a vertex was entered through. And the next vertex is determined as the
one connected to the port $(l_{i} + e_{i}) \mod d_{v_{i}}$. We define
$l_{0} = 0$ and the notion $(e_{0},\dots,e_{k})^{\ast}$ for periodic sequences.
It can be shown that a periodic sequence produces a closed walk through a
graph.
\begin{proof}
  We argue that there is only a finite amount of triples of the
  form $(v,l,i)$ where currently the agent is on vertex $v$, entered
  this vertex through port $l$ and is currently at index $i$ of the exploration
  sequence. For two triples $(v',l',i')$ and $(v'',l'',i'')$ that both lead to
  $(v,l,i)$ it is easy to see, that $(v',l',i') = (v'',l'',i'')$. Thus, for
  every triple there is a unique predecessor and successor which implies due to
  the finiteness of the triples $(v,l,i)$ and that the agent moves infinitely
  it follows that the first triple has to be valid infinitly often. This means
  a periodic exploration sequence yields a closed walk.
\end{proof}

From the following result of \cite{logspacealg} we present how we can obtain
an $(\mathcal{O}(1),0,\mathcal{O}(\log n))$ pebble machine that finds a closed
walk of at least $n$ distinct vertices in any graph with bounded degree.
\begin{thm}
  \label{thm:logalg}
There is an algorithm $M\in L$ which produces a universal exploration sequence
for every regular graph with $n$ vertices.
\end{thm}
First we argue that we can use this algorithm to find a universal exploration
sequence of the form $e=(e_{0},\dots,e_{k})^{\ast}$ that traverses $n$ distinct
vertices for any 3-regular graph and requires only $\mathcal{O}(\log n)$
memory. Therefore we rely on the traversal sequence of $M$ from Theorem
\ref{thm:logalg} and take from that the first $k:=3n\cdot c$ indices where
$c$ denotes the number of configurations of $M$. We can now be assured that
$e$ actually is a universal traversal sequence for any 3-regular graph because
otherwise $M$ would have already looped in a strict subset of vertices of some
3-regular graph. This contradicts that $M$ produces a universal exploration
sequence for any graph with $n$ vertices.

We can now find the $(\mathcal{O}(1),0,\mathcal{O}(\log n))$ pebble machine we
are looking for.
\begin{thm}
  \label{thm:pebblewalk}
  There is a $(\mathcal{O}(1),0,\mathcal{O}(\log n))$ pebble machine which
  explores every given graph $G$ with bounded degree $\Delta$ either completly
  or at least loops on $n$ distinct vertices.
\end{thm}
\begin{proof}
  The main idea is to use the adapted algorithm $A$ to find for an
  universal exploration sequence for a 3-regular graph from above. Therefore
  we take $G$ and transform it to a 3-regular graph on which $A$ finds the
  corresponding universal exploration sequence. The transformation replaces
  any node $v$ with degree $d$ by $3d$ nodes which then form a circle where
  every nodes has degree $3$. The edges of $v$ are moved to nodes in the
  circle. Specifically the edge with port $i$ is replaced by 3 edges which are
  attached to $(v,i), (v,i+d), (v,i+2d)$. (Note that the other
  vertex attached to the edge is replaced by the same construction and therfore
  offers enough ports for the newly introduced edges.) The following picture
  illustrates this construction:\todo{add picture}
  
  This simulation yields at most $3\Delta n^{2}$ many nodes and can be emulated
  with $\mathcal{O}(1)$ many memory space since it is only needed to store
  the second component of the inserted nodes which is bounded by $3\Delta$.
  Furthermore $A$ can be run on this constructed Graph and only needs
  $\mathcal{0}(\log n)$ space since $\mathcal{O}(\log(3\Delta n^{2})) =
  \mathcal{O}(\log(3) + \log(\Delta) + 2\log(n)) = \mathcal{O}(\log n)$.
  Which yields the required $(\mathcal{O}(1),0,\mathcal{O}(\log n))$ pebble
  machine.
\end{proof}

In order to obtain the desired boundary of $\log\log n$ space and $\log\log n$
pebbles we show that a pebble machine can be simulated by storing its tape
content by pebbles that are placed on a closed walk.
\begin{thm}
  For every graph $G$ a $(s,p,2m)$ pebble machine $M$ can be simulated by
  a $(cs,p + c,m)$ pebble machine that simulates the walk of $M$ or explores
  $G$.
\end{thm}
\begin{proof}
  The main idea of this simulation is to store the tape of $M$ by pebbles
  placed on a closed walk in the graph. We show that every node on this closed
  walk can be given an index and a pebble placed on a node represents the
  binary representation of the index as the content of $M$'s tape. Again we
  refer to the following picture for illustration: \todo{add picture}
  We will first introduce the algorithms used to implement the simulation and
  afterwards we will argue why this simulation respects the given space
  boundarys.  Let $M_{\text{Walk}}$ be a pebble machine that yields a closed
  walk on $G$. (Such a pebble machine exists due to Theorem
  \ref{thm:pebblewalk}.) In order to manage the simulation we use some
  variables: $\Tid, \Tsteps, \Twalk, \Thead$ where $\Tid$ is used to identify
  the index of a vertex on the walk of $M_{\text{Walk}}$, $\Twalk$ is the tape
  content of $M_{\text{Walk}}$ which can therefore be restarted by setting
  $\Twalk$ to 0, $\Tsteps$ counts the number of steps taken by
  $M_{\text{Walk}}$, and $\Thead$ stores where $M$'s head is positioned.
  Furthermore we need some pebbles to mark certain vertices of the closed walk:
  $p_{\text{start}}, p_{\text{tmp}}, p_{\text{next}}$ and additionally the
  pebbles that are placed on the walk to store $M$'s tape content
  $P_{M} = \left\{p_{1},p_{2},\dots\right\}$.
  Now the different procedures used for the simulation can be presented:
  \begin{description}
    \item[Step():] Simulates on step according to $M_{\text{Walk}}$ and
      increases $\Tsteps$.
    \item[FindPebble($p_{i}$):] Executes \emph{Step()} until the pebble $p_{i}$
      is observed.
    \item[Restart():] Goes to the beginning of the closed walk by
      \emph{FindPebble($p_{\text{start}}$)} and sets $\Tsteps,\Tid,\Twalk$ to 0
    \item[NextDistinctVertex()] Finds the next distinct vertex of the walk. If
      there are no more vertices on the walk (we will see that this can be
      computed since the used walk is of constant size) it simply executes
      \emph{Restart()}. Otherwise it does one step and drops $p_{\text{tmp}}$
      to mark this vertex. It then stores the current amount of steps as well
      as the current state of $M_{\text{Walk}}$ (introducing two auxiliary
      variables $\Tsteps',\Twalk'$). It then restarts $M_{\text{Walk}}$ and
      moves to $p_{\text{tmp}}$ by \emph{FindPebble($p_{\text{tmp}}$)}. If
      it used the same amount of steps as stored in $\Tsteps'$ then this is the
      first occurence of the vertex in the closed walk and therefore it is a
      new distinct vertex and $\Tid$ can be increased. Otherwise the context of
      $M_{\text{Walk}}$ is restored and the next vertex is checked.
    \item[GetPebbleId($p_{i}$):] Finds the index of the vertex $p_{i}$ is
      placed on. Beginning from the start of the closed walk
      (found by executing \emph{Restart()} it moves along distinct vertices
      (by using \emph{NextDistinctVertex()}) and returns $\Tid$ as soon as
      $p_{i}$ is observed.
    \item[PutPebbleAtId($p_{i},\mathit{id}$):] Puts pebble $p_i$ at a certain
      index. First it picks up $p_{i}$ and restarts the walk. Then it executes
      $\mathit{id}$ times \emph{NextDistinctVertex()} and drops $p_{i}$.
    \item[ReadBit():] Reads the $\Thead$'s bit of $M$'s tape. $\Thead$ gives
      the position of the bit that should be read. The walk of
      $M_{\text{walk}}$ is only considered to a certain length (as we will see
      later) which also determines the blocks in which $M$'s tape is separated.
      (The index of a vertex is used to encode one block.) Therefore we can use
      this length of the walk which pebble encodes the corresponding block
      which is obtained.  And then the actually needed bit of the index is
      returned.
    \item[WriteBit($b$):] Writes $b$ to $\Thead$'s bit of $M$'s tape. First
      $\Thead$'s bit is obtained (by \emph{ReadBit()}). And if it is actually
      changed the corresponding pebble is moved to store the new value of the
      memory cell. Thus, if the bit is flipped from 0 to 1 we increase $p_{i}$
      where $i$ is the encoded memory cell index by $2^{\Thead\bmod m_{1}}$
      where $m_{1}$ encodes the length of the considered walk. And if the bit
      is flipped from 1 to 0 we decrease $p_{i}$'s index by
      $2^{\Thead\bmod m_{1}}$.
  \end{description}
  These are the procedures used to simulate $M$. We will now discuss the space
  boundarys and afterwards conclude with showing how the simulation actually
  operates. Recall that $M$ is a $(s,p,2m)$ pebble machine. For the simulating
  

\end{proof}


\setquotestyle{english}
\printbibliography
\end{document}
